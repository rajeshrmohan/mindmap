<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindMap Web App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden; /* Prevent body scrollbars */
        }

        #controls {
            padding: 10px;
            background-color: #333;
            color: white;
            width: 100%;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            z-index: 100;
        }

        #controls button {
            padding: 8px 15px;
            margin: 0 5px;
            background-color: #5cb85c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        #controls button.secondary-btn {
            background-color: #0275d8;
        }
        #controls button.secondary-btn:hover {
            background-color: #025aa5;
        }
        #controls button:hover {
            background-color: #4cae4c;
        }
        #loadFileInput {
            display: none; /* Hidden file input */
        }

        #mindmap-container {
            position: relative;
            width: 100%;
            flex-grow: 1; /* Takes remaining space */
            overflow: auto; /* Allows scrolling within the container for large maps */
            background-color: #e9e9e9;
            background-image:
                linear-gradient(rgba(0,0,0,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0,0,0,0.1) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        #mindmap-svg {
            width: 2000px; /* Large canvas for drawing */
            height: 2000px;
            display: block; /* Remove extra space below SVG */
        }

        .node {
            cursor: grab;
            transition: transform 0.1s ease-out;
        }
        .node.dragging {
            cursor: grabbing;
        }
        .node-rect {
            fill: #add8e6;
            stroke: #4682b4;
            stroke-width: 2;
            rx: 10; /* Rounded corners */
            ry: 10;
        }
        .node-text {
            font-size: 14px;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none; /* So text doesn't interfere with drag */
            fill: #333;
            user-select: none;
        }
        .connection-line {
            stroke: #555;
            stroke-width: 2;
            fill: none;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .modal-content h2 {
            margin-top: 0;
        }
        .modal-content label {
            display: block;
            margin-top: 10px;
            margin-bottom: 5px;
        }
        .modal-content input[type="text"],
        .modal-content textarea,
        .modal-content select {
            width: calc(100% - 22px);
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .modal-content textarea {
            resize: vertical;
            min-height: 80px;
        }
        .modal-buttons {
            text-align: right;
            margin-top: 20px;
        }
        .modal-buttons button {
            padding: 10px 15px;
            margin-left: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .modal-buttons .save-btn { background-color: #5cb85c; color: white; }
        .modal-buttons .save-btn:hover { background-color: #4cae4c; }
        .modal-buttons .delete-btn { background-color: #d9534f; color: white; }
        .modal-buttons .delete-btn:hover { background-color: #c9302c; }
        .modal-buttons .cancel-btn { background-color: #f0ad4e; color: white; }
        .modal-buttons .cancel-btn:hover { background-color: #ec971f; }
        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-btn:hover,
        .close-btn:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Node Details Modal */
        #nodeDetailsModalContent p {
            margin: 5px 0;
            word-break: break-word;
        }

    </style>
</head>
<body>

    <div id="controls">
        <button id="addNodeBtn">Add Node</button>
        <button id="saveMapBtn" class="secondary-btn">Save Map</button>
        <button id="loadMapBtn" class="secondary-btn">Load Map</button>
        <input type="file" id="loadFileInput" accept=".json">
    </div>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
    </div>

    <!-- Add/Edit Node Modal -->
    <div id="nodeModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeNodeModal()">&times;</span>
            <h2 id="nodeModalTitle">Add Node</h2>
            <input type="hidden" id="nodeIdInput">
            <div>
                <label for="nodeTitleInput">Title:</label>
                <input type="text" id="nodeTitleInput" placeholder="Node Title">
            </div>
            <div>
                <label for="nodeDescriptionInput">Description:</label>
                <textarea id="nodeDescriptionInput" placeholder="Node Description"></textarea>
            </div>
            <div>
                <label for="nodeParentSelect">Parent Node (optional):</label>
                <select id="nodeParentSelect">
                    <option value="">-- No Parent (Root) --</option>
                </select>
            </div>
            <div class="modal-buttons">
                <button id="saveNodeBtn" class="save-btn" onclick="saveNode()">Save</button>
                <button id="deleteNodeBtn" class="delete-btn" style="display:none;" onclick="deleteNode()">Delete</button>
                <button class="cancel-btn" onclick="closeNodeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Node Details Modal -->
    <div id="nodeDetailsModal" class="modal">
        <div class="modal-content" id="nodeDetailsModalContent">
            <span class="close-btn" onclick="closeDetailsModal()">&times;</span>
            <h2 id="detailsTitle">Node Details</h2>
            <p><strong>ID:</strong> <span id="detailsId"></span></p>
            <p><strong>Description:</strong> <span id="detailsDescription"></span></p>
            <p><strong>Parent ID:</strong> <span id="detailsParentId"></span></p>
            <div class="modal-buttons">
                 <button class="save-btn" onclick="editNodeFromDetails()">Edit</button>
                 <button class="cancel-btn" onclick="closeDetailsModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const mindmapSVG = document.getElementById('mindmap-svg');
        const nodeModal = document.getElementById('nodeModal');
        const nodeDetailsModal = document.getElementById('nodeDetailsModal');
        const addNodeBtn = document.getElementById('addNodeBtn');
        const saveMapBtn = document.getElementById('saveMapBtn');
        const loadMapBtn = document.getElementById('loadMapBtn');
        const loadFileInput = document.getElementById('loadFileInput');


        const nodeIdInput = document.getElementById('nodeIdInput');
        const nodeTitleInput = document.getElementById('nodeTitleInput');
        const nodeDescriptionInput = document.getElementById('nodeDescriptionInput');
        const nodeParentSelect = document.getElementById('nodeParentSelect');
        const nodeModalTitle = document.getElementById('nodeModalTitle');
        const saveNodeBtn = document.getElementById('saveNodeBtn');
        const deleteNodeBtn = document.getElementById('deleteNodeBtn');

        let nodes = [];
        let selectedNodeElement = null;
        let offset = { x: 0, y: 0 };
        let isDragging = false;
        let currentEditingNodeId = null; // Used for both edit modal and details modal context

        const NODE_WIDTH = 150;
        const NODE_HEIGHT = 50;
        const PADDING = 10; // Padding inside the node rect for text

        // --- Node Data Management ---
        function generateId() {
            return 'node_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
        }

        function addNode(title, description, parentId = null, x, y, existingId = null, width = NODE_WIDTH, height = NODE_HEIGHT) {
            const id = existingId || generateId(); // Use existing ID if provided (for loading)
            const newNode = {
                id,
                title,
                description,
                parentId,
                x: x !== undefined ? x : (parentId ? getNodeById(parentId).x + NODE_WIDTH + 50 : 50),
                y: y !== undefined ? y : (parentId ? getNodeById(parentId).y : 50 + nodes.length * (NODE_HEIGHT + 20)),
                width: width, // Use provided width or default
                height: height // Use provided height or default
            };
            // Avoid duplicate IDs if adding manually after a load
            if (!existingId && getNodeById(id)) {
                newNode.id = generateId(); // Regenerate if collision (unlikely but good practice)
            }
            nodes.push(newNode);
            return newNode;
        }


        function getNodeById(id) {
            return nodes.find(node => node.id === id);
        }

        function updateNode(id, newTitle, newDescription, newParentId) {
            const node = getNodeById(id);
            if (node) {
                node.title = newTitle;
                node.description = newDescription;
                if (newParentId !== id && !isDescendant(newParentId, id)) {
                     node.parentId = newParentId;
                } else if (newParentId === id) {
                    alert("A node cannot be its own parent.");
                } else if (isDescendant(newParentId, id)) {
                    alert("Cannot set parent to a descendant node (creates a cycle).");
                }
            }
            return node;
        }
        
        function isDescendant(potentialChildId, potentialParentId) {
            if (!potentialChildId || !potentialParentId) return false;
            let currentNode = getNodeById(potentialChildId);
            while (currentNode && currentNode.parentId) {
                if (currentNode.parentId === potentialParentId) return true;
                currentNode = getNodeById(currentNode.parentId);
            }
            return false;
        }


        function removeNode(id) {
            const nodeIndex = nodes.findIndex(node => node.id === id);
            if (nodeIndex > -1) {
                const nodeToRemove = nodes[nodeIndex];
                nodes.splice(nodeIndex, 1);
                // Re-parent children of the deleted node
                const children = nodes.filter(n => n.parentId === id);
                children.forEach(child => {
                    child.parentId = nodeToRemove.parentId; // Re-parent to deleted node's parent
                });
            }
        }

        // --- Rendering ---
        function renderMindMap() {
            mindmapSVG.innerHTML = ''; // Clear previous render

            nodes.forEach(node => {
                if (node.parentId) {
                    const parentNode = getNodeById(node.parentId);
                    if (parentNode) {
                        drawConnection(node, parentNode);
                    }
                }
            });

            nodes.forEach(node => {
                drawNode(node);
            });
        }

        function drawNode(node) {
            const group = document.createElementNS(svgNS, 'g');
            group.setAttribute('id', `group-${node.id}`);
            group.setAttribute('class', 'node');
            group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
            group.dataset.id = node.id;

            const rect = document.createElementNS(svgNS, 'rect');
            rect.setAttribute('class', 'node-rect');
            rect.setAttribute('width', node.width);
            rect.setAttribute('height', node.height);
            
            const text = document.createElementNS(svgNS, 'text');
            text.setAttribute('class', 'node-text');
            text.setAttribute('x', node.width / 2);
            text.setAttribute('y', node.height / 2);
            
            const words = node.title.split(' ');
            let line = '';
            let tspan;
            const maxCharsPerLine = Math.floor((node.width - 2 * PADDING) / 8); 

            for (let i = 0; i < words.length; i++) {
                const testLine = line + words[i] + ' ';
                if (testLine.length > maxCharsPerLine && i > 0) {
                    tspan = document.createElementNS(svgNS, 'tspan');
                    tspan.setAttribute('x', node.width / 2);
                    tspan.setAttribute('dy', '1.2em'); 
                    tspan.textContent = line.trim();
                    text.appendChild(tspan);
                    line = words[i] + ' ';
                } else {
                    line = testLine;
                }
            }
            tspan = document.createElementNS(svgNS, 'tspan');
            tspan.setAttribute('x', node.width / 2);
            if (text.childNodes.length > 0) tspan.setAttribute('dy', '1.2em');
            tspan.textContent = line.trim();
            text.appendChild(tspan);

            const numLines = text.childNodes.length;
            const textBlockHeight = numLines * (14 * 1.2); 
            text.setAttribute('y', (node.height / 2) - (textBlockHeight / 2) + (14 * 0.6)); 

            group.appendChild(rect);
            group.appendChild(text);
            mindmapSVG.appendChild(group);

            group.addEventListener('mousedown', onNodeMouseDown);
            group.addEventListener('click', onNodeClick);
        }
        
        function drawConnection(childNode, parentNode) {
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('class', 'connection-line');
            line.setAttribute('x1', parentNode.x + parentNode.width / 2);
            line.setAttribute('y1', parentNode.y + parentNode.height / 2);
            line.setAttribute('x2', childNode.x + childNode.width / 2);
            line.setAttribute('y2', childNode.y + childNode.height / 2);
            mindmapSVG.insertBefore(line, mindmapSVG.firstChild); 
        }


        // --- Node Interaction (Drag) ---
        function onNodeMouseDown(e) {
            if (e.button !== 0) return; 
            isDragging = true;
            selectedNodeElement = e.currentTarget;
            selectedNodeElement.classList.add('dragging');
            
            const CTM = mindmapSVG.getScreenCTM().inverse();
            const pt = mindmapSVG.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM);

            const nodeData = getNodeById(selectedNodeElement.dataset.id);
            offset.x = svgP.x - nodeData.x;
            offset.y = svgP.y - nodeData.y;

            document.addEventListener('mousemove', onNodeMouseMove);
            document.addEventListener('mouseup', onNodeMouseUp);
        }

        function onNodeMouseMove(e) {
            if (!isDragging || !selectedNodeElement) return;
            e.preventDefault();
            
            const CTM = mindmapSVG.getScreenCTM().inverse();
            const pt = mindmapSVG.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;
            const svgP = pt.matrixTransform(CTM);

            const nodeData = getNodeById(selectedNodeElement.dataset.id);
            nodeData.x = svgP.x - offset.x;
            nodeData.y = svgP.y - offset.y;
            
            nodeData.x = Math.max(0, Math.min(nodeData.x, mindmapSVG.width.baseVal.value - nodeData.width));
            nodeData.y = Math.max(0, Math.min(nodeData.y, mindmapSVG.height.baseVal.value - nodeData.height));

            renderMindMap(); 
        }

        function onNodeMouseUp(e) {
            if (!isDragging) return;
            isDragging = false;
            if(selectedNodeElement) {
                selectedNodeElement.classList.remove('dragging');
            }
            selectedNodeElement = null;
            document.removeEventListener('mousemove', onNodeMouseMove);
            document.removeEventListener('mouseup', onNodeMouseUp);
        }

        // --- Node Click (Details) ---
        function onNodeClick(e) {
            if (e.detail > 1 || (e.target.closest('.node') && e.target.closest('.node').classList.contains('dragging-finished-check'))) {
                if(e.target.closest('.node')) e.target.closest('.node').classList.remove('dragging-finished-check');
                return;
            }
            if (selectedNodeElement && selectedNodeElement.classList.contains('dragging')) {
                 selectedNodeElement.classList.add('dragging-finished-check'); 
                 return;
            }

            const nodeElement = e.currentTarget;
            const nodeId = nodeElement.dataset.id;
            const node = getNodeById(nodeId);
            if (node) {
                currentEditingNodeId = nodeId; 
                openDetailsModal(node);
            }
        }

        // --- Modals Management ---
        function openNodeModal(nodeToEdit = null) {
            populateParentSelect(nodeToEdit ? nodeToEdit.id : null);
            if (nodeToEdit) {
                nodeModalTitle.textContent = 'Edit Node';
                nodeIdInput.value = nodeToEdit.id;
                nodeTitleInput.value = nodeToEdit.title;
                nodeDescriptionInput.value = nodeToEdit.description;
                nodeParentSelect.value = nodeToEdit.parentId || "";
                deleteNodeBtn.style.display = 'inline-block';
                currentEditingNodeId = nodeToEdit.id;
            } else {
                nodeModalTitle.textContent = 'Add Node';
                nodeIdInput.value = '';
                nodeTitleInput.value = '';
                nodeDescriptionInput.value = '';
                nodeParentSelect.value = '';
                deleteNodeBtn.style.display = 'none';
                currentEditingNodeId = null;
            }
            nodeModal.style.display = 'flex';
            nodeTitleInput.focus();
        }

        function closeNodeModal() {
            nodeModal.style.display = 'none';
        }

        function saveNode() {
            const id = nodeIdInput.value;
            const title = nodeTitleInput.value.trim();
            const description = nodeDescriptionInput.value.trim();
            const parentId = nodeParentSelect.value || null;

            if (!title) {
                alert('Title is required.');
                return;
            }

            if (id) { 
                updateNode(id, title, description, parentId);
            } else { 
                let parentNode = parentId ? getNodeById(parentId) : null;
                let initialX = parentNode ? parentNode.x + parentNode.width / 2 - NODE_WIDTH / 2 : 100;
                let initialY = parentNode ? parentNode.y + parentNode.height + 50 : 100;
                
                if (!parentNode) {
                    let rootNodes = nodes.filter(n => !n.parentId);
                    initialY = 50 + rootNodes.length * (NODE_HEIGHT + 30);
                }
                addNode(title, description, parentId, initialX, initialY);
            }
            renderMindMap();
            closeNodeModal();
        }

        function deleteNode() {
            if (currentEditingNodeId && confirm('Are you sure you want to delete this node and its connections? Child nodes will be re-parented to this node\'s parent (or become root).')) {
                removeNode(currentEditingNodeId);
                renderMindMap();
                closeNodeModal();
                currentEditingNodeId = null; // Clear after deletion
            }
        }

        function populateParentSelect(excludeNodeId = null) {
            nodeParentSelect.innerHTML = '<option value="">-- No Parent (Root) --</option>';
            nodes.forEach(node => {
                if (node.id === excludeNodeId) return; 
                if (excludeNodeId && isDescendant(node.id, excludeNodeId)) return;

                const option = document.createElement('option');
                option.value = node.id;
                option.textContent = `${node.title} (ID: ${node.id.substring(0,10)}...)`;
                nodeParentSelect.appendChild(option);
            });
        }

        function openDetailsModal(node) {
            document.getElementById('detailsTitle').textContent = node.title;
            document.getElementById('detailsId').textContent = node.id;
            document.getElementById('detailsDescription').textContent = node.description || 'N/A';
            document.getElementById('detailsParentId').textContent = node.parentId || 'N/A (Root Node)';
            nodeDetailsModal.style.display = 'flex';
        }
        
        function editNodeFromDetails() {
            if (currentEditingNodeId) {
                const nodeToEdit = getNodeById(currentEditingNodeId);
                closeDetailsModal(); 
                openNodeModal(nodeToEdit); 
            }
        }

        function closeDetailsModal() {
            nodeDetailsModal.style.display = 'none';
            // Don't clear currentEditingNodeId here if details modal might be reopened for same node.
            // It's set when a node is clicked or when edit modal opens.
        }

        // --- Save and Load Functionality ---
        function handleSaveMap() {
            let fileName = prompt("Enter filename for your MindMap (e.g., my_map):", "mindmap");
            if (fileName) {
                if (!fileName.toLowerCase().endsWith('.json')) {
                    fileName += '.json';
                }
                const dataStr = JSON.stringify(nodes, null, 2); // Pretty print JSON
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);
                
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = fileName;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url);
                alert("Map saved as " + fileName);
            }
        }

        function handleLoadMapTrigger() {
            loadFileInput.click(); // Trigger click on hidden file input
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            if (file.type !== "application/json") {
                alert("Please select a valid .json MindMap file.");
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedNodes = JSON.parse(e.target.result);
                    if (Array.isArray(loadedNodes) && 
                        (loadedNodes.length === 0 || 
                         (loadedNodes[0] && typeof loadedNodes[0].id !== 'undefined' && typeof loadedNodes[0].title !== 'undefined'))) {
                        // Basic validation passed
                        nodes = []; // Clear current nodes
                        loadedNodes.forEach(nodeData => {
                            // Add node with all its saved properties
                            addNode(
                                nodeData.title,
                                nodeData.description,
                                nodeData.parentId,
                                nodeData.x,
                                nodeData.y,
                                nodeData.id, // Pass existing ID
                                nodeData.width || NODE_WIDTH, // Use saved width or default
                                nodeData.height || NODE_HEIGHT // Use saved height or default
                            );
                        });
                        renderMindMap();
                        alert("MindMap loaded successfully!");
                    } else {
                        alert("Invalid MindMap file format.");
                    }
                } catch (error) {
                    console.error("Error parsing MindMap file:", error);
                    alert("Error loading MindMap file. It might be corrupted or not a valid JSON.");
                } finally {
                     // Reset file input to allow loading the same file again
                    event.target.value = null;
                }
            };
            reader.onerror = function() {
                alert("Error reading file.");
                event.target.value = null;
            };
            reader.readAsText(file);
        }


        // --- Event Listeners ---
        addNodeBtn.addEventListener('click', () => openNodeModal());
        saveMapBtn.addEventListener('click', handleSaveMap);
        loadMapBtn.addEventListener('click', handleLoadMapTrigger);
        loadFileInput.addEventListener('change', handleFileLoad);


        // Close modals if user clicks outside content
        window.onclick = function(event) {
            if (event.target == nodeModal) {
                closeNodeModal();
            }
            if (event.target == nodeDetailsModal) {
                closeDetailsModal();
            }
        }

        // --- Initial Setup ---
        function initializeMindMap() {
            // Add a default root node or leave blank for user to load/create
            if (nodes.length === 0) { // Only add default if no map is loaded immediately
                 addNode('My MindMap', 'This is the central idea.', null, 300, 50);
            }
            renderMindMap();
        }

        document.addEventListener('DOMContentLoaded', initializeMindMap);

    </script>
</body>
</html>